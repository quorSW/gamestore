"""
Paypalich — платёжная система для России
Поддерживает: СБП, карты РФ
Документация: https://paypalich.com/api/

Принцип работы:
1. Создаём счёт через API → получаем ссылку на оплату
2. Пользователь платит через СБП или карту
3. Paypalich шлёт webhook на наш сервер с результатом
4. Мы подтверждаем оплату и выдаём товар
"""

import hashlib
import hmac
import aiohttp
import json
from typing import Optional, Dict


class PaypalichPayment:
    def __init__(self, shop_id: str, secret_key: str):
        self.shop_id = shop_id
        self.secret_key = secret_key
        self.base_url = "https://paypalich.com/api/v1"

    def _sign(self, params: dict) -> str:
        """Подпись запроса через HMAC-SHA256"""
        # Сортируем параметры по ключу и склеиваем
        sorted_params = sorted(params.items())
        sign_string = "&".join(f"{k}={v}" for k, v in sorted_params)
        return hmac.new(
            self.secret_key.encode(),
            sign_string.encode(),
            hashlib.sha256
        ).hexdigest()

    async def create_invoice(
        self,
        order_id: int,
        amount: float,
        description: str,
        pay_method: str = "sbp",  # "sbp" или "card"
        success_url: str = "",
        fail_url: str = ""
    ) -> Optional[Dict]:
        """
        Создать счёт на оплату.
        Возвращает словарь с полями:
        - payment_url: ссылка для пользователя
        - payment_id: ID платежа в системе Paypalich
        """
        params = {
            "shop_id": self.shop_id,
            "order_id": str(order_id),
            "amount": f"{amount:.2f}",
            "currency": "RUB",
            "description": description,
            "pay_method": pay_method,  # sbp / card_rf
            "success_url": success_url,
            "fail_url": fail_url,
        }
        params["sign"] = self._sign(params)

        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{self.base_url}/create",
                json=params,
                headers={"Content-Type": "application/json"}
            ) as resp:
                try:
                    data = await resp.json()
                    if data.get("status") == "success":
                        return {
                            "payment_url": data["data"]["url"],
                            "payment_id": data["data"]["payment_id"],
                        }
                    else:
                        print(f"Paypalich error: {data}")
                        return None
                except Exception as e:
                    print(f"Paypalich request failed: {e}")
                    return None

    async def get_status(self, payment_id: str) -> Optional[str]:
        """
        Проверить статус платежа.
        Возможные статусы: pending, paid, failed, cancelled
        """
        params = {
            "shop_id": self.shop_id,
            "payment_id": payment_id,
        }
        params["sign"] = self._sign(params)

        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{self.base_url}/status",
                json=params
            ) as resp:
                try:
                    data = await resp.json()
                    return data.get("data", {}).get("status")
                except:
                    return None

    async def is_paid(self, payment_id: str) -> bool:
        status = await self.get_status(payment_id)
        return status == "paid"

    def verify_webhook(self, data: dict, received_sign: str) -> bool:
        """Проверить подпись входящего webhook от Paypalich"""
        params = {k: v for k, v in data.items() if k != "sign"}
        expected = self._sign(params)
        return hmac.compare_digest(expected, received_sign)
