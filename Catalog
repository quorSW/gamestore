from aiogram import Router, F
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from payment import PaypalichPayment
import aiosqlite

router = Router()


@router.message(F.text == "üõç –ö–∞—Ç–∞–ª–æ–≥")
async def catalog(message: Message, db):
    games = await db.get_games_list()
    subs = await db.get_subscriptions_list()

    text = "üõç <b>–ö–∞—Ç–∞–ª–æ–≥ —Ç–æ–≤–∞—Ä–æ–≤</b>\n\n–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:"
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üéÆ –ò–≥—Ä–æ–≤–∞—è –≤–∞–ª—é—Ç–∞", callback_data="cat_games")],
        [InlineKeyboardButton(text="ü§ñ AI –ø–æ–¥–ø–∏—Å–∫–∏", callback_data="cat_ai")],
        [InlineKeyboardButton(text="üéµ –ú—É–∑—ã–∫–∞ –∏ —Å—Ç—Ä–∏–º–∏–Ω–≥", callback_data="cat_stream")],
    ])
    await message.answer(text, reply_markup=kb, parse_mode="HTML")


@router.callback_query(F.data == "open_catalog")
async def open_catalog_cb(callback: CallbackQuery):
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üéÆ –ò–≥—Ä–æ–≤–∞—è –≤–∞–ª—é—Ç–∞", callback_data="cat_games")],
        [InlineKeyboardButton(text="ü§ñ AI –ø–æ–¥–ø–∏—Å–∫–∏", callback_data="cat_ai")],
        [InlineKeyboardButton(text="üéµ –ú—É–∑—ã–∫–∞ –∏ —Å—Ç—Ä–∏–º–∏–Ω–≥", callback_data="cat_stream")],
    ])
    await callback.message.edit_text("üõç <b>–ö–∞—Ç–∞–ª–æ–≥ —Ç–æ–≤–∞—Ä–æ–≤</b>\n\n–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:", reply_markup=kb, parse_mode="HTML")


@router.callback_query(F.data == "cat_games")
async def cat_games(callback: CallbackQuery, db):
    games = await db.get_games_list()
    buttons = [[InlineKeyboardButton(text=f"üéÆ {g}", callback_data=f"game_{g}")] for g in games]
    buttons.append([InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="open_catalog")])
    await callback.message.edit_text(
        "üéÆ <b>–ò–≥—Ä–æ–≤–∞—è –≤–∞–ª—é—Ç–∞</b>\n\n–î–æ—Å—Ç—É–ø–Ω—ã–µ –∏–≥—Ä—ã:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons),
        parse_mode="HTML"
    )


@router.callback_query(F.data == "cat_ai")
async def cat_ai(callback: CallbackQuery, db):
    subs = await db.get_subscriptions_by_category("subscription")
    buttons = [[InlineKeyboardButton(text=f"‚ú® {s}", callback_data=f"sub_{s}")] for s in subs]
    buttons.append([InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="open_catalog")])
    await callback.message.edit_text(
        "ü§ñ <b>AI –ø–æ–¥–ø–∏—Å–∫–∏</b>\n\n–í—ã–±–µ—Ä–∏ —Å–µ—Ä–≤–∏—Å:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons),
        parse_mode="HTML"
    )


@router.callback_query(F.data == "cat_stream")
async def cat_stream(callback: CallbackQuery, db):
    subs = await db.get_subscriptions_by_category("streaming")
    buttons = [[InlineKeyboardButton(text=f"üéµ {s}", callback_data=f"stream_{s}")] for s in subs]
    buttons.append([InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="open_catalog")])
    await callback.message.edit_text(
        "üéµ <b>–ú—É–∑—ã–∫–∞ –∏ —Å—Ç—Ä–∏–º–∏–Ω–≥</b>\n\n–í—ã–±–µ—Ä–∏ —Å–µ—Ä–≤–∏—Å:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons),
        parse_mode="HTML"
    )


async def _show_products(callback: CallbackQuery, db, game: str, back_cb: str):
    products = await db.get_products(game=game)
    if not products:
        await callback.answer("–¢–æ–≤–∞—Ä–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç!", show_alert=True)
        return

    EMOJIS = {"Fortnite": "‚ö°", "Brawl Stars": "üíé", "ChatGPT Plus": "ü§ñ", "Claude Pro": "üß†",
               "Midjourney": "üé®", "Grok Premium": "‚ú¶", "Perplexity Pro": "üîç",
               "GitHub Copilot": "üêô", "Cursor AI": "üñ±Ô∏è", "Canva Pro": "‚úèÔ∏è",
               "Adobe CC": "üÖ∞Ô∏è", "Spotify": "üéµ", "YouTube": "‚ñ∂Ô∏è",
               "Apple Music": "üçé", "Tidal HiFi": "üåä"}
    emoji = EMOJIS.get(game, "‚ú®")

    buttons = []
    for p in products:
        disc = int((1 - p["price"] / p["original_price"]) * 100) if p.get("original_price") else 0
        disc_txt = f" üî•‚àí{disc}%" if disc else ""
        buttons.append([InlineKeyboardButton(
            text=f"{p['name']} ‚Äî {int(p['price'])}‚ÇΩ{disc_txt}",
            callback_data=f"product_{p['id']}"
        )])
    buttons.append([InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=back_cb)])

    await callback.message.edit_text(
        f"{emoji} <b>{game}</b>\n\n–í—ã–±–µ—Ä–∏ –ø–∞–∫–µ—Ç:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons),
        parse_mode="HTML"
    )


@router.callback_query(F.data.startswith("game_"))
async def show_game(callback: CallbackQuery, db):
    game = callback.data[5:]
    await _show_products(callback, db, game, "cat_games")


@router.callback_query(F.data.startswith("sub_"))
async def show_sub(callback: CallbackQuery, db):
    game = callback.data[4:]
    await _show_products(callback, db, game, "cat_ai")


@router.callback_query(F.data.startswith("stream_"))
async def show_stream(callback: CallbackQuery, db):
    game = callback.data[7:]
    await _show_products(callback, db, game, "cat_stream")


@router.callback_query(F.data.startswith("product_"))
async def show_product(callback: CallbackQuery, db):
    product_id = int(callback.data[8:])
    product = await db.get_product(product_id)
    if not product:
        await callback.answer("–¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω!", show_alert=True)
        return

    available = await db.count_available_keys(product_id)
    stock = f"‚úÖ –í –Ω–∞–ª–∏—á–∏–∏: {available} —à—Ç." if available > 0 else "‚ö†Ô∏è –£—Ç–æ—á–Ω–∏—Ç–µ –Ω–∞–ª–∏—á–∏–µ —É –ø–æ–¥–¥–µ—Ä–∂–∫–∏"

    disc = ""
    if product.get("original_price"):
        pct = int((1 - product["price"] / product["original_price"]) * 100)
        disc = f"\n~~{int(product['original_price'])}‚ÇΩ~~ ‚Üí —Å–∫–∏–¥–∫–∞ {pct}%"

    back_map = {"game": "cat_games", "subscription": "cat_ai", "streaming": "cat_stream"}
    back_cb = back_map.get(product["category"], "open_catalog")

    text = (
        f"{product['emoji']} <b>{product['name']}</b>\n"
        f"üè∑ {product['game']}\n\n"
        f"{product.get('description', '')}\n\n"
        f"üí∞ –¶–µ–Ω–∞: <b>{int(product['price'])}‚ÇΩ</b>{disc}\n"
        f"{stock}\n\n"
        f"üí≥ –û–ø–ª–∞—Ç–∞: –°–ë–ü –∏–ª–∏ –∫–∞—Ä—Ç–∞ –†–§ (Paypalich)\n"
        f"‚ö° –í—ã–¥–∞—á–∞ –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –ø–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã"
    )

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üì≤ –û–ø–ª–∞—Ç–∏—Ç—å —á–µ—Ä–µ–∑ –°–ë–ü", callback_data=f"buy_{product_id}_sbp")],
        [InlineKeyboardButton(text="üí≥ –û–ø–ª–∞—Ç–∏—Ç—å –∫–∞—Ä—Ç–æ–π –†–§", callback_data=f"buy_{product_id}_card")],
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=back_cb)],
    ])
    await callback.message.edit_text(text, reply_markup=kb, parse_mode="HTML")


@router.callback_query(F.data.startswith("buy_"))
async def buy_product(callback: CallbackQuery, db, config):
    parts = callback.data.split("_")
    # format: buy_{product_id}_{method}
    product_id = int(parts[1])
    pay_method = parts[2] if len(parts) > 2 else "sbp"

    product = await db.get_product(product_id)
    if not product:
        await callback.answer("–¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω!", show_alert=True)
        return

    available = await db.count_available_keys(product_id)
    if available == 0:
        await callback.answer("‚ö†Ô∏è –¢–æ–≤–∞—Ä –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ù–∞–ø–∏—à–∏ –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É!", show_alert=True)
        return

    # Create order first
    order_id = await db.create_order(
        user_id=callback.from_user.id,
        product_id=product_id,
        amount=product["price"],
        payment_id="pending"
    )

    # Create Paypalich invoice
    paypalich = PaypalichPayment(config.PAYPALICH_SHOP_ID, config.PAYPALICH_SECRET)
    method_label = "–°–ë–ü" if pay_method == "sbp" else "–∫–∞—Ä—Ç–∞ –†–§"

    result = await paypalich.create_invoice(
        order_id=order_id,
        amount=product["price"],
        description=f"GameStore: {product['name']}",
        pay_method=pay_method,
        success_url=f"https://t.me/{(await callback.bot.me()).username}"
    )

    if not result:
        await callback.answer("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ!", show_alert=True)
        return

    payment_id = result["payment_id"]
    payment_url = result["payment_url"]

    # Update order with payment_id
    async with aiosqlite.connect(config.DB_PATH) as conn:
        await conn.execute("UPDATE orders SET payment_id=? WHERE id=?", (payment_id, order_id))
        await conn.commit()

    method_icon = "üì≤" if pay_method == "sbp" else "üí≥"

    await callback.message.edit_text(
        f"{method_icon} <b>–û–ø–ª–∞—Ç–∞ —á–µ—Ä–µ–∑ {method_label}</b>\n\n"
        f"{product['emoji']} {product['name']}\n"
        f"üí∞ –°—É–º–º–∞: <b>{int(product['price'])}‚ÇΩ</b>\n\n"
        f"1. –ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫ –æ–ø–ª–∞—Ç–µ\n"
        f"2. –û–ø–ª–∞—Ç–∏ —É–¥–æ–±–Ω—ã–º —Å–ø–æ—Å–æ–±–æ–º\n"
        f"3. –ù–∞–∂–º–∏ ¬´–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–ø–ª–∞—Ç—É¬ª ‚Äî –ø–æ–ª—É—á–∏—à—å —Ç–æ–≤–∞—Ä\n\n"
        f"‚è± –°—Å—ã–ª–∫–∞ –¥–µ–π—Å—Ç–≤—É–µ—Ç 30 –º–∏–Ω—É—Ç\n"
        f"üîí –ë–µ–∑–æ–ø–∞—Å–Ω–æ ¬∑ –∑–∞—â–∏—â–µ–Ω–æ Paypalich",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text=f"{method_icon} –ü–µ—Ä–µ–π—Ç–∏ –∫ –æ–ø–ª–∞—Ç–µ", url=payment_url)],
            [InlineKeyboardButton(text="‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–ø–ª–∞—Ç—É", callback_data=f"checkpay_{order_id}")],
            [InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="open_catalog")],
        ]),
        parse_mode="HTML"
    )


@router.callback_query(F.data.startswith("checkpay_"))
async def check_payment(callback: CallbackQuery, db, config):
    order_id = int(callback.data[9:])
    order = await db.get_order(order_id)

    if not order or order["user_id"] != callback.from_user.id:
        await callback.answer("–ó–∞–∫–∞–∑ –Ω–µ –Ω–∞–π–¥–µ–Ω!", show_alert=True)
        return

    if order["status"] == "completed":
        await callback.answer("‚úÖ –≠—Ç–æ—Ç –∑–∞–∫–∞–∑ —É–∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω!", show_alert=True)
        return

    if order["payment_id"] == "pending":
        await callback.answer("‚è≥ –ü–ª–∞—Ç—ë–∂ –µ—â—ë –Ω–µ —Å–æ–∑–¥–∞–Ω. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.", show_alert=True)
        return

    paypalich = PaypalichPayment(config.PAYPALICH_SHOP_ID, config.PAYPALICH_SECRET)
    paid = await paypalich.is_paid(order["payment_id"])

    if not paid:
        await callback.answer("‚è≥ –û–ø–ª–∞—Ç–∞ –ø–æ–∫–∞ –Ω–µ –ø–æ—Å—Ç—É–ø–∏–ª–∞. –ü–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ –∏ –ø—Ä–æ–≤–µ—Ä—å —Å–Ω–æ–≤–∞!", show_alert=True)
        return

    await _deliver_order(callback, db, config, order_id, callback.from_user.id, order["product_id"])


async def _deliver_order(callback, db, config, order_id, user_id, product_id):
    key = await db.get_available_key(product_id)
    product = await db.get_product(product_id)
    await db.complete_order(order_id)

    if key:
        await db.use_key(key["id"], order_id)
        text = (
            f"‚úÖ <b>–ó–∞–∫–∞–∑ #{order_id} –≤—ã–ø–æ–ª–Ω–µ–Ω!</b>\n\n"
            f"{product['emoji']} <b>{product['name']}</b>\n\n"
            f"üîë –¢–≤–æ–π –∫–æ–¥:\n"
            f"<code>{key['key_value']}</code>\n\n"
            f"–ù–∞–∂–º–∏ –Ω–∞ –∫–æ–¥ —á—Ç–æ–±—ã —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å!\n"
            f"–°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–∫—É–ø–∫—É! üéÆ"
        )
    else:
        text = (
            f"‚úÖ <b>–û–ø–ª–∞—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∞! –ó–∞–∫–∞–∑ #{order_id}</b>\n\n"
            f"{product['emoji']} <b>{product['name']}</b>\n\n"
            f"‚è≥ –¢–æ–≤–∞—Ä –±—É–¥–µ—Ç –¥–æ—Å—Ç–∞–≤–ª–µ–Ω –≤ —Ç–µ—á–µ–Ω–∏–µ 15 –º–∏–Ω—É—Ç.\n"
            f"–í–æ–ø—Ä–æ—Å—ã: {config.SUPPORT_USERNAME}"
        )
        for admin_id in config.ADMIN_IDS:
            try:
                await callback.bot.send_message(
                    admin_id,
                    f"‚ö†Ô∏è <b>–†–£–ß–ù–ê–Ø –í–´–î–ê–ß–ê</b>\n\n"
                    f"–ó–∞–∫–∞–∑: #{order_id}\n"
                    f"–¢–æ–≤–∞—Ä: {product['name']}\n"
                    f"–ü–æ–∫—É–ø–∞—Ç–µ–ª—å: {user_id}\n\n"
                    f"–ù–µ—Ç –∫–ª—é—á–µ–π –≤ –±–∞–∑–µ! –î–æ–±–∞–≤—å —á–µ—Ä–µ–∑ /admin",
                    parse_mode="HTML"
                )
            except:
                pass

    await callback.message.edit_text(text, parse_mode="HTML")
